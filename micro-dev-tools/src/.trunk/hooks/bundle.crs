// cargo-deps: yaml-rust, regex, fs_extra
extern crate fs_extra;
extern crate regex;
extern crate yaml_rust;
use fs_extra::dir::CopyOptions;
use regex::Regex;
use std::{
    collections::HashMap,
    env, fmt,
    fmt::Display,
    fs,
    path::{Path, PathBuf},
    process::Command,
    str::FromStr,
};
use yaml_rust::*;

const ANY_PATH_NAME: &str = "_";

#[macro_export]
macro_rules! write_err {
    ($($arg:tt)*) => {
        eprint!("\x1b[91m");
        eprintln!($($arg)*);
        eprint!("\x1b[0m");
    };
}

fn main() {
    let bundle_config = BundleConfig {
        profile: env::var("TRUNK_PROFILE").unwrap(),
        stage: env::var("TRUNK_STAGING_DIR").unwrap().stripped(r"\\?\").to_string(),
        html_file: env::var("TRUNK_HTML_FILE").unwrap().stripped(r"\\?\").to_string(),
        source_dir: env::var("TRUNK_SOURCE_DIR").unwrap().stripped(r"\\?\").to_string(),
        dist_dir: env::var("TRUNK_DIST_DIR").unwrap().stripped(r"\\?\").to_string(),
        public_url: env::var("TRUNK_PUBLIC_URL").unwrap(),
        build_config_path: ".build/build.yml".to_string(),
    };

    let path = env::args().skip(1).next().unwrap();
    println!("[bundle] : bundle targets in {}", &path);
    let targets = targets(&bundle_config, &path);
    for target in targets {
        println!("[bundle] : target : {}", &target.as_os_str().to_string_lossy());
        fs::read_to_string(target.as_path().join(&bundle_config.build_config_path))
            .ok()
            .map(|conf| {
                let result = YamlLoader::load_from_str(&conf);
                if result.is_err() {
                    eprintln!("[bundle] : config contains invalid syntax : {}", result.as_ref().unwrap_err());
                }
                result.ok()
            })
            .flatten()
            .iter()
            .map(|docs| replace_config(&bundle_config, &target, &docs[0]))
            .map(|doc| doc.map(|doc| read_config(&target, &doc)))
            .map(flatten)
            .for_each(|config| {
                if let Err(err) = config {
                    write_err!("[bundle] : {}", err);
                } else {
                    let config = config.unwrap();
                    build(&bundle_config, &config);
                }
            });
    }

    fn flatten<T, E>(result: Result<Result<T, E>, E>) -> Result<T, E> {
        match result {
            Ok(r) => return r,
            Err(err) => return Err(err),
        }
    }

    trait StrippedExtension {
        fn stripped<'a>(&'a self, prefix: &Self) -> &'a Self;
    }

    impl StrippedExtension for str {
        fn stripped<'a>(&'a self, prefix: &str) -> &'a Self {
            self.strip_prefix(prefix).unwrap_or(self)
        }
    }
}

fn build(bundle_config: &BundleConfig, config: &BuildConfig) {
    println!("[bundle] : build : {}", &config.target.as_os_str().to_string_lossy());

    let succeeded = config
        .paths
        .iter()
        .filter(|(k, _)| is_match(k, &bundle_config.profile))
        .fold(true, |prev, (n, p)| prev && execute_path(n, p));

    if !succeeded || !copy_dist(bundle_config, config) {
        write_err!("[bundle] : failed to build : {}", &config.target.as_os_str().to_string_lossy());
    }

    fn is_match(pattern: &str, profile: &str) -> bool {
        match pattern {
            ANY_PATH_NAME => true,
            _ => profile == pattern,
        }
    }

    fn execute_path(name: &str, path: &Vec<Step>) -> bool {
        println!("[bundle] : execute path : {}", name);
        let result = path.iter().fold(true, |prev_is_succeeded, step| {
            if !prev_is_succeeded {
                return false;
            }
            execute_step(step)
        });

        if !result {
            eprint!("\x1b[91m");
            eprintln!("[bundle] : faild to execute path : {}", name);
            eprint!("\x1b[0m");
        }

        result
    }

    fn execute_step(step: &Step) -> bool {
        let mut cmd = Command::new(&step.exec);
        cmd.current_dir(&step.working_dir).args(&step.args);
        println!("[bundle] : run : {}", &step.label);
        let result = cmd.output();
        match result {
            Err(err) => {
                write_err!("[bundle] : faild to run step {} : {}", &step.label, err);
                false
            }
            Ok(output) => {
                println!("{}", String::from_utf8_lossy(&output.stdout).as_ref());
                if !output.stderr.is_empty() {
                    eprintln!("{}", String::from_utf8_lossy(&output.stderr).as_ref());
                };

                let success = output.status.success();
                if !success {
                    write_err!("[bundle] : faild to build");
                }
                success
            }
        }
    }
}

fn copy_dist(bundle_config: &BundleConfig, config: &BuildConfig) -> bool {
    println!("[bundle] : copy dist : {}", config.dist.as_os_str().to_string_lossy());
    let entries = if let Ok(entries) = fs::read_dir(config.dist.as_path()) {
        entries
    } else {
        write_err!("{} was not exist", config.dist.as_os_str().to_string_lossy());
        return false;
    };
    let mut options = CopyOptions::new();
    options.overwrite = true;
    let output = Path::new(&bundle_config.stage).join(config.target.as_path());
    let items = entries.filter_map(|e| e.ok().map(|e| e.path())).collect::<Vec<_>>();
    let result = fs::create_dir_all(output.as_path());
    if let Err(err) = result.as_ref() {
        write_err!("[bundle] : cannot create output dir {}", err);
        return false;
    }

    let result = fs_extra::copy_items(&items, output, &options);

    if let Err(err) = result.as_ref() {
        write_err!("[bundle] : cannot copy {}", err);
        return false;
    }
    return true;
}

fn read_config(target: &impl AsRef<Path>, doc: &Yaml) -> Result<BuildConfig, ConfigErr> {
    let dist = doc["dist"].as_str().unwrap_or("dist");
    let dist = target.as_ref().join(dist);
    let build = &doc["build"];
    let paths = match build {
        Yaml::Array(steps) => {
            let any = parse_steps(target, &steps)?;
            let mut map = HashMap::new();
            map.insert(ANY_PATH_NAME.to_string(), any);
            map
        }
        Yaml::Hash(hash) => {
            let paths = hash
                .iter()
                .filter_map(|(k, v)| {
                    let steps = v.as_vec().map(|steps| parse_steps(target, steps))?;
                    let key = k.as_str()?;
                    return Some(steps.map(|s| (key.to_string(), s)));
                })
                .collect::<Result<HashMap<_, _>, _>>()?;
            paths
        }
        _ => HashMap::new(),
    };

    return Ok(BuildConfig {
        target: target.as_ref().to_path_buf(),
        dist,
        paths,
    });

    fn parse_steps(target: &impl AsRef<Path>, steps: &Vec<Yaml>) -> Result<Vec<Step>, ConfigErr> {
        let steps = steps.iter().map(|step| {
            let run = step["run"].as_str();
            if run.is_none() {
                return Err(ConfigErr::NoRunProperty);
            }
            let run = run.unwrap();
            let splitted = split(run);
            let exec = splitted[0].to_string();
            let args: Vec<_> = splitted.iter().skip(1).map(|s| s.to_string()).collect();
            let label = if let Some(label) = step["label"].as_str() {
                label.to_string()
            } else {
                args.iter().fold(exec.as_str().to_string(), |mut label, arg| {
                    label.push(' ');
                    label.push_str(arg);
                    label
                })
            };
            let mut working_dir = target.as_ref().to_path_buf();
            if let Some(dir) = step["working_dir"].as_str() {
                working_dir.push(dir);
            }

            let step = Step {
                exec: exec.to_string(),
                working_dir,
                args,
                label,
            };
            return Ok(step);
        });

        let mut vec = Vec::new();
        for step in steps {
            match step {
                Ok(step) => vec.push(step),
                Err(msg) => return Err(msg),
            }
        }

        return Ok(vec);
    }
}

fn split<'a>(args: &'a str) -> Vec<&'a str> {
    let mut stack = Vec::new();
    enum State {
        Initial,
        Plain { offset: usize },
        Quoted { offset: usize, quote: char },
        QuoteEnd { offset: usize },
    }
    let mut state = State::Initial;
    for (i, c) in args.char_indices() {
        state = match state {
            State::Initial => {
                if c.is_whitespace() {
                    State::Initial
                } else if matches!(c, '"' | '\'') {
                    State::Quoted { offset: i, quote: c }
                } else {
                    State::Plain { offset: i }
                }
            }

            State::Plain { offset } => {
                if c.is_whitespace() {
                    stack.push(&args[offset..i]);
                    State::Initial
                } else if matches!(c, '"' | '\'') {
                    stack.push(&args[offset..i]);
                    State::Quoted { offset, quote: c }
                } else {
                    State::Plain { offset }
                }
            }

            State::Quoted { offset, quote } => {
                if c == quote {
                    State::QuoteEnd { offset }
                } else {
                    State::Quoted { offset, quote }
                }
            }

            State::QuoteEnd { offset } => {
                stack.push(&args[offset..i]);
                if c.is_whitespace() {
                    State::Initial
                } else if matches!(c, '"' | '\'') {
                    State::Quoted { offset: i, quote: c }
                } else {
                    State::Plain { offset: i }
                }
            }
        }
    }

    match state {
        State::Plain { offset } => {
            stack.push(&args[offset..]);
        }
        State::Quoted { offset, .. } => {
            stack.push(&args[offset..]);
        }
        State::QuoteEnd { offset } => {
            stack.push(&args[offset..]);
        }
        _ => {}
    }

    return stack;
}

fn replace_config(bundle_config: &BundleConfig, target: &impl AsRef<Path>, doc: &Yaml) -> Result<Yaml, ConfigErr> {
    let mut clone = doc.clone();
    let pattern = Regex::new(r"\$\{\{(.*?)}}").unwrap();
    let unresolved = replace(bundle_config, target, &pattern, &mut clone, doc);
    return unresolved.into_iter().find_map(|(_, err)| err).map(|e| Err(e)).unwrap_or_else(|| Ok(clone));

    fn replace<'a>(
        bundle_config: &'a BundleConfig,
        target: &impl AsRef<Path>,
        pattern: &'a Regex,
        clone: &'a mut Yaml,
        doc: &'a Yaml,
    ) -> Vec<(&'a mut String, Option<ConfigErr>)> {
        use Yaml::*;
        let mut unresolved = match clone {
            String(ref mut s) => vec![(s, None)],
            Hash(ref mut hash) => hash
                .iter_mut()
                .filter_map(|(k, v)| k.as_str().map(|k| (k, v)))
                .flat_map(|(k, v)| replace(bundle_config, target, pattern, v, &doc[k]))
                .collect(),
            Array(ref mut array) => array
                .iter_mut()
                .enumerate()
                .flat_map(|(i, v)| replace(bundle_config, target, pattern, v, &doc[i]))
                .collect(),
            _ => vec![],
        };

        swap_remove_all_mut(&mut unresolved, |(s, error)| {
            let replaced = pattern.replace_all(s, |caps: &regex::Captures| {
                let reference = caps[1].trim();
                resolve(bundle_config, target, reference, doc).unwrap_or_else(|e| {
                    if error.is_none() {
                        *error = Some(e);
                    }
                    caps[0].to_string()
                })
            });
            **s = replaced.into_owned();
            error.is_none()
        });

        return unresolved;
    }
}

fn resolve(bundle_config: &BundleConfig, target: &impl AsRef<Path>, reference: &str, doc: &Yaml) -> Result<String, ConfigErr> {
    const ENV_PREFIX: &str = "env:";
    const CONF_PREFIX: &str = "config:";
    const SELF_PREFIX: &str = "self:";
    if let Some(name) = reference.strip_prefix(ENV_PREFIX) {
        if let Ok(var) = env::var(name) {
            return Ok(var);
        } else {
            return Err(ConfigErr::ReferenceNotFound {
                msg: format!("environment value of {} was not exist", name),
            });
        }
    } else if let Some(name) = reference.strip_prefix(CONF_PREFIX) {
        let value = match name {
            "profile" => bundle_config.profile.clone(),
            "stage" => bundle_config.stage.clone(),
            "public_url" => bundle_config.public_url.clone(),
            "html_file" => bundle_config.html_file.clone(),
            "source_dir" => bundle_config.source_dir.clone(),
            "dist_dir" => bundle_config.dist_dir.clone(),
            "build_config_path" => bundle_config.build_config_path.clone(),
            _ => {
                return Err(ConfigErr::ReferenceNotFound {
                    msg: format!("config of {} was not exist", name),
                })
            }
        };
        return Ok(value);
    } else if let Some(name) = reference.strip_prefix(SELF_PREFIX) {
        let value = match name {
            "identity" => target.as_ref().as_os_str().to_string_lossy().as_ref().replace('\\', "/"),
            _ => {
                return Err(ConfigErr::ReferenceNotFound {
                    msg: format!("self:{} was not exist", name),
                })
            }
        };
        return Ok(value);
    } else {
        let v = access(doc, reference);
        return to_string(v).ok_or(ConfigErr::ReferenceNotFound {
            msg: format!("reference of {} was not resolved", reference),
        });
    }

    fn access<'a, 'b>(mut doc: &'a Yaml, path: &'b str) -> &'a Yaml {
        for key in path.split('.') {
            doc = match &doc[key] {
                Yaml::BadValue => usize::from_str(key).map(|i| &doc[i]).unwrap_or(&Yaml::BadValue),
                n @ _ => n,
            };
        }
        return doc;
    }
    fn to_string(doc: &Yaml) -> Option<String> {
        match doc {
            Yaml::Real(s) => Some(s.clone()),
            Yaml::Integer(i) => Some(i.to_string()),
            Yaml::String(s) => Some(s.clone()),
            Yaml::Boolean(f) => Some(f.to_string()),
            Yaml::Null => Some("".to_string()),
            _ => None,
        }
    }
}

fn swap_remove_all_mut<T: Sized>(vec: &mut Vec<T>, mut predicate: impl FnMut(&mut T) -> bool) {
    let mut rest = vec.len();
    while let Some(pos) = vec[..rest].iter_mut().rposition(&mut predicate) {
        vec.swap_remove(pos);
        rest = pos;
    }
}

fn targets(bundle_config: &BundleConfig, path: &impl AsRef<Path>) -> Vec<PathBuf> {
    let dir = if let Ok(dir) = fs::read_dir(path) {
        dir
    } else {
        return vec![];
    };

    return dir
        .filter_map(|e| {
            let e = e.ok()?;
            let path = e.path();
            let config = path.join(&*bundle_config.build_config_path);
            if config.try_exists().unwrap_or(false) {
                return Some(vec![path]);
            } else {
                return Some(targets(bundle_config, &path));
            }
        })
        .flatten()
        .collect::<Vec<_>>();
}

#[derive(Debug)]
struct Step {
    label: String,
    exec: String,
    args: Vec<String>,
    working_dir: PathBuf,
}

#[derive(Debug)]
struct BundleConfig {
    profile: String,
    stage: String,
    public_url: String,
    html_file: String,
    source_dir: String,
    dist_dir: String,
    build_config_path: String,
}

#[derive(Debug)]
struct BuildConfig {
    target: PathBuf,
    dist: PathBuf,
    paths: HashMap<String, Vec<Step>>,
}

#[derive(Debug, Clone)]
enum ConfigErr {
    NoRunProperty,
    ReferenceNotFound { msg: String },
}

impl Display for ConfigErr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use ConfigErr::*;
        match self {
            NoRunProperty => write!(
                f,
                "{}",
                "\
            build step must have run property.
            
            === example ===

            build:
              release:
                - run: ls
              debug:
                - run: echo debug
              _:
                - run: cd ..
            
            ===============

            build:
              - run: cd ..
            
            ===============
            "
            ),
            ReferenceNotFound { msg } => write!(f, "{}", msg),
        }
    }
}
