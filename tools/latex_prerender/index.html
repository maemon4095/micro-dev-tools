<!DOCTYPE html>
<html>

<head>
    <script>
        MathJax = {
            startup: {
                typeset: false
            }
        };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body style="display: grid;
             grid-template: 'header' auto
                            'main' 1fr / 1fr;">
    <div style="grid-area: header; display: flex; flex-direction: row; gap: 1em; align-items: stretch;">
        <textarea id="pattern_input">`(.*?)`</textarea>
        <hr>
        <input id="file_input" type="file" accept="image/svg+xml, text/*" />
        <hr>
        <a id="download"> download </a>
    </div>
    <div id="output" style="grid-area: main; overflow: auto;"></div>
</body>
<script>
    const file_input = document.getElementById('file_input');
    const output = document.getElementById('output');
    const pattern_input = document.getElementById('pattern_input');
    const button_download = document.getElementById('download');

    file_input.addEventListener('input', (inputEvent) => {
        MathJax.texReset();
        const pat_text = pattern_input.value;
        const pattern = new RegExp(pat_text, 'g');
        const [file] = inputEvent.target.files;
        if (!file || !pattern) return;
        const reader = new FileReader();
        reader.addEventListener('load', (e) => {
            const text = e.target.result;
            const result = render(text, file.type, pattern);
            output.replaceChildren(...result.children);

            const oldhref = button_download.href;
            if (oldhref) {
                URL.revokeObjectURL(oldhref);
            }
            const blob = new Blob([result.text], { type: file.type });
            button_download.href = URL.createObjectURL(blob);
            button_download.setAttribute('download', `prerendered-${file.name}`);
        });
        reader.readAsText(file);
    });

    function render(text, mime, pattern) {
        switch (mime) {
            case 'text/html':
            case 'text/xml':
            case 'application/xml':
            case 'application/xhtml+xml':
            case 'image/svg+xml': {
                const parser = new DOMParser();
                const dom = parser.parseFromString(text, mime);
                if (!!dom) {
                    replaceDom(dom, pattern);
                    return { text: new XMLSerializer().serializeToString(dom), children: [...dom.children] };
                } else {
                    const t = renderText(text, pattern);
                    return { text: t, children: [text] };
                }
            }
            default: {
                const t = renderText(text, pattern);
                return { text: t, children: [text] };
            }
        }
    }


    function renderText(tex, pattern) {
        return tex.replaceAll(pattern, (m, c) => {
            const container = MathJax.tex2svg(c ?? m);
            return container.querySelector('svg').outerHTML ?? m;
        });
    }

    function replaceDom(dom, pattern) {
        const children = dom.children;
        if (children.length === 0 && !!dom.textContent) {
            const rendered = renderText(dom.textContent, pattern);
            dom.innerHTML = rendered;
        }
        for (const e of children) {
            replaceDom(e, pattern);
        }
    }
</script>

</html>